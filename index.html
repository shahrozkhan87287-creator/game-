<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Shahroz’s Mini Mario Run</title>
<style>
  body{margin:0;background:#0b0f24;color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:740px;margin:0 auto;padding:10px}
  .hud{display:flex;justify-content:space-between;gap:8px;margin:8px 0}
  .pill{background:#0008;border:1px solid #ffffff30;border-radius:12px;padding:8px 12px;font-weight:900}
  #game{display:block;width:100%;height:auto;border:1px solid #ffffff22;border-radius:12px;box-shadow:0 14px 40px rgba(0,0,0,.55);background:#89d6ff}
  .tip{opacity:.9;text-align:center;font-size:12px;margin-top:6px}
</style>
</head>
<body>
<div class="wrap">
  <div class="hud">
    <div class="pill">Score: <span id="score">0</span></div>
    <div class="pill">Best: <span id="best">0</span></div>
    <div class="pill">Created by <b>Shahroz Khan</b></div>
  </div>
  <!-- Fixed logical size so physics/collisions are consistent -->
  <canvas id="game" width="640" height="360" aria-label="Shahroz’s Mini Mario Run"></canvas>
  <div class="tip">Jump: Space / ↑ / Tap • Avoid pipes • Grab ⭐ coins • Enter/Tap to restart</div>
</div>

<script>
(() => {
  const cv = document.getElementById('game');
  const ctx = cv.getContext('2d');
  const W = cv.width, H = cv.height;
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');

  // Ground line
  const GY = H - 56;

  // Player
  const P = { x: 120, y: GY-28, w: 22, h: 28, vy: 0, on: true, hold:false, buf:0, coyote:0 };
  const GRAV = 0.55, JUMP = -10.2, HOLD = -0.25, FALL_MAX = 12.5;

  // World
  let running = false, over = false, t = 0, speed = 3.2, score = 0;
  let objs = []; // {type:'pipe'|'coin', x,y,w,h,passed?,taken?}
  let clouds = [];
  let wantJump = false;

  // High score
  let best = +localStorage.getItem('mmr_best') || 0;
  bestEl.textContent = best;

  // Input (one button)
  function press(){ wantJump = true; P.hold = true; }
  function release(){ P.hold = false; }
  cv.addEventListener('pointerdown', press, {passive:true});
  addEventListener('pointerup', release, {passive:true});
  addEventListener('keydown', e=>{
    if(e.repeat) return;
    if(e.code==='Space'||e.code==='ArrowUp'||e.code==='KeyW') press();
    if((e.code==='Enter'||e.code==='NumpadEnter') && !running) start();
  });
  addEventListener('keyup', e=>{
    if(e.code==='Space'||e.code==='ArrowUp'||e.code==='KeyW') release();
  });
  cv.addEventListener('click', ()=>{ if(!running) start(); });

  function start(){
    running = true; over = false; t = 0; speed = 3.2; score = 0;
    P.x = 120; P.y = GY - P.h; P.vy = 0; P.on = true; P.hold=false; P.buf=0; P.coyote=0; wantJump=false;
    objs.length = 0; clouds.length = 0;
    for(let i=0;i<5;i++) clouds.push({x: rnd(0,W), y: rnd(20,120), s: rnd(0.5,1.2)});
    let x = 420;
    for(let i=0;i<4;i++){ spawnChunk(x); x += irnd(220,320); }
    scoreEl.textContent = '0';
  }

  function gameOver(){
    running = false; over = true;
    if(score > best){ best = score; localStorage.setItem('mmr_best', best); bestEl.textContent = best; }
    draw(true);
  }

  function rnd(a,b){ return Math.random()*(b-a)+a; }
  function irnd(a,b){ return Math.floor(rnd(a,b)); }
  function hit(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
  }

  // Spawning
  function spawnPipe(x){
    const h = irnd(34, 64);
    objs.push({type:'pipe', x, y: GY - h, w: 36, h, passed:false});
  }
  function spawnCoin(x,y){
    objs.push({type:'coin', x, y, w:14, h:14, taken:false});
  }
  function spawnChunk(x){
    const r = Math.random();
    if(r < 0.6){
      spawnPipe(x);
      if(Math.random()<0.7) spawnCoin(x+10, GY - irnd(90,130));
    }else{
      spawnPipe(x);
      spawnPipe(x + irnd(90,130));
      if(Math.random()<0.5) spawnCoin(x+50, GY - irnd(110,140));
    }
  }

  function update(){
    if(!running){ draw(false); requestAnimationFrame(update); return; }
    t++;

    // Clouds
    for(const c of clouds){
      c.x -= speed*0.25*c.s; if(c.x<-60){ c.x=W+40; c.y=irnd(20,120); c.s=rnd(0.5,1.2); }
    }

    // Jump buffering & coyote time
    if(wantJump){ P.buf = 8; wantJump=false; }
    if(P.on) P.coyote = 6; else if(P.coyote>0) P.coyote--;

    // Take jump if buffered
    if(P.buf>0){
      if(P.on || P.coyote>0){ P.vy = JUMP; P.on=false; P.buf=0; }
      else P.buf--;
    }
    if(P.hold && P.vy < 0) P.vy += HOLD; // variable jump height

    // Physics
    P.vy += GRAV; if(P.vy>FALL_MAX) P.vy = FALL_MAX;
    P.y += P.vy;
    if(P.y + P.h >= GY){ P.y = GY - P.h; P.vy = 0; P.on = true; } else P.on = false;

    // Move & manage obstacles
    for(const o of objs){
      o.x -= speed;
      // score on passing pipes
      if(o.type==='pipe' && !o.passed && o.x + o.w < P.x - P.w/2){
        o.passed = true; score += 1; scoreEl.textContent = score;
      }
    }
    while(objs.length && objs[0].x < -80) objs.shift();
    const lastX = objs.length ? objs[objs.length-1].x : 400;
    if(lastX < W + 60) spawnChunk(W + irnd(140, 260));

    // Collisions
    const px = P.x, py = P.y, pw = P.w, ph = P.h;
    for(let i=objs.length-1;i>=0;i--){
      const o = objs[i];
      if(o.type==='coin'){
        if(!o.taken && hit(px,py,pw,ph, o.x,o.y,o.w,o.h)){
          o.taken = true; score += 5; scoreEl.textContent = score; objs.splice(i,1);
        }
      }else if(o.type==='pipe'){
        if(hit(px,py,pw,ph, o.x,o.y,o.w,o.h)){ gameOver(); return; }
      }
    }

    // Ramp difficulty
    if(t % 240 === 0) speed = Math.min(7.2, speed + 0.25);

    draw(false);
    requestAnimationFrame(update);
  }

  function draw(showOver){
    // Sky
    const sky = ctx.createLinearGradient(0,0,0,H);
    sky.addColorStop(0,'#6ec9ff'); sky.addColorStop(1,'#89d6ff');
    ctx.fillStyle = sky; ctx.fillRect(0,0,W,H);

    // Clouds
    for(const c of clouds){
      ctx.fillStyle='rgba(255,255,255,.9)'; cloud(c.x,c.y,26*c.s);
    }

    // Ground
    ctx.fillStyle='#6ab04c'; ctx.fillRect(0,GY,W,H-GY);
    ctx.fillStyle='#3d7a2f'; for(let x=0;x<W;x+=32) ctx.fillRect(x,GY+22,22,6);

    // Obstacles
    for(const o of objs){
      if(o.type==='pipe'){
        ctx.fillStyle='#2ecc71'; ctx.fillRect(o.x,o.y,o.w,o.h);
        ctx.fillStyle='#27ae60'; ctx.fillRect(o.x-6,o.y-10,o.w+12,10);
        ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.strokeRect(o.x,o.y,o.w,o.h);
      }else{
        ctx.fillStyle='#ffd166';
        ctx.beginPath(); ctx.arc(o.x+o.w/2,o.y+o.h/2,o.w/2,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle='#ffef9a'; ctx.stroke();
      }
    }

    // Player (red dude + hat)
    // Shadow
    ctx.fillStyle='rgba(0,0,0,.15)';
    ctx.beginPath(); ctx.ellipse(P.x + P.w/2, P.y + P.h + 6, 16, 6, 0, 0, Math.PI*2); ctx.fill();
    // Body
    ctx.fillStyle='#ff6b6b'; roundRect(P.x, P.y, P.w, P.h, 4); ctx.fill();
    // Hat
    ctx.fillStyle='#e74c3c'; ctx.fillRect(P.x-2, P.y-6, P.w+4, 6);

    // Game Over banner
    if(showOver){
      ctx.fillStyle='rgba(0,0,0,.55)';
      ctx.fillRect(W/2-140, H/2-60, 280, 120);
      ctx.strokeStyle='#ffffff33'; ctx.strokeRect(W/2-140, H/2-60, 280, 120);
      ctx.fillStyle='#fff'; ctx.font='bold 26px system-ui, sans-serif';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('GAME OVER', W/2, H/2-12);
      ctx.font='16px system-ui, sans-serif';
      ctx.fillText('Press Enter / Tap to restart', W/2, H/2+20);
    }
  }

  function cloud(x,y,r){
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+r*0.7,y+r*0.3,r*0.7,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x-r*0.7,y+r*0.35,r*0.6,0,Math.PI*2); ctx.fill();
  }
  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  // Kick off
  requestAnimationFrame(update);
  // Auto-start so it just works — comment this out if you want manual start
  start();
})();
</script>
</body>
</html>
