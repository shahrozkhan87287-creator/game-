<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Shahroz’s Dash</title>
<meta name="description" content="A tiny, working arcade game. Move left/right, dodge blocks, grab stars. Created by Shahroz Khan.">
<style>
  :root{
    --bg1:#0b0f24; --bg2:#141a3a; --panel:#ffffff16; --glow:#6cf; --accent:#7cffc4; --warn:#ff6b6b; --text:#eaf1ff;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(135deg,var(--bg1),var(--bg2));color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;touch-action:manipulation;overscroll-behavior:none}
  .wrap{max-width:520px;margin:0 auto;padding:12px}
  #game{display:block;width:100%;height:auto;background:#0b0f24;border:1px solid #ffffff22;border-radius:16px;box-shadow:0 16px 46px rgba(0,0,0,.55)}
  .hud{display:flex;justify-content:space-between;align-items:center;gap:8px;margin:8px 0}
  .pill{background:var(--panel);border:1px solid #ffffff26;border-radius:14px;padding:8px 12px;font-weight:800}
  .btn{appearance:none;border:none;cursor:pointer;background:linear-gradient(135deg,#7cffc4,#6cf);color:#102;border-radius:14px;padding:10px 14px;font-weight:900;box-shadow:0 10px 24px rgba(0,0,0,.35)}
  .btn:active{transform:scale(.98)}
  .credit{opacity:.85;text-align:center;font-size:12px;margin-top:6px}
  /* Overlay */
  #overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#0a0c20cc;backdrop-filter:blur(8px);z-index:10}
  .panel{background:#0c1128;border:1px solid #ffffff26;border-radius:16px;padding:18px;width:min(92vw,480px);text-align:center;box-shadow:0 24px 60px rgba(0,0,0,.6)}
  h1{margin:0 0 6px}
  .muted{opacity:.9}
  .row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-top:12px}
  /* Touch controls (big left/right pads) */
  .pads{display:flex;gap:10px;margin-top:8px}
  .pad{flex:1;background:#00000040;border:1px solid #ffffff22;border-radius:12px;padding:10px 0}
  .pad span{opacity:.9}
  @media (min-width:800px){ .pads{display:none} } /* hide pads on desktop */
</style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="pill">Score: <span id="score">0</span></div>
      <div class="pill">Best: <span id="best">0</span></div>
      <button class="btn" id="start">Start / Restart</button>
    </div>

    <canvas id="game" width="420" height="680" aria-label="Shahroz’s Dash game"></canvas>

    <div class="pads">
      <div class="pad" id="padL"><center><span>⬅️ LEFT</span></center></div>
      <div class="pad" id="padR"><center><span>➡️ RIGHT</span></center></div>
    </div>

    <div class="credit">Created by <b>Shahroz Khan</b> • Tap left/right pads on phone or use ← → keys</div>
  </div>

  <!-- Overlay (shown on first load & on game over) -->
  <div id="overlay">
    <div class="panel">
      <h1>Shahroz’s Dash</h1>
      <p class="muted">Move left/right. Dodge the red blocks. Grab ⭐ stars for points. Speed slowly increases.</p>
      <div class="row">
        <button class="btn" id="play">Play</button>
      </div>
      <p class="muted" style="margin-top:6px">Mobile: tap LEFT/RIGHT pads • Desktop: use arrow keys</p>
    </div>
  </div>

<script>
(() => {
  // ===== Basic canvas setup (crisp & responsive) =====
  const cv = document.getElementById('game');
  const ctx = cv.getContext('2d');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const startBtn= document.getElementById('start');
  const overlay = document.getElementById('overlay');
  const playBtn = document.getElementById('play');
  const padL = document.getElementById('padL');
  const padR = document.getElementById('padR');

  // High score
  let best = +localStorage.getItem('sd_best') || 0;
  bestEl.textContent = best;

  // Resize to devicePixelRatio but keep logical coords
  function fit() {
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const r = cv.getBoundingClientRect();
    cv.width = Math.round(r.width * dpr);
    cv.height = Math.round(r.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  new ResizeObserver(fit).observe(cv);
  fit();

  // ===== Game state =====
  const state = {
    running:false, over:false,
    px: cv.width/(window.devicePixelRatio||1)/2, // player x
    py: (cv.height/(window.devicePixelRatio||1)) - 60, // player y
    pw: 46, ph: 20, vx: 0,
    moveLeft:false, moveRight:false,
    speed: 3, // world scroll
    score:0,
    items:[], // hazards & stars
    t:0
  };

  // Input (keyboard)
  addEventListener('keydown', e=>{
    if(e.key==='ArrowLeft' || e.key==='a' || e.key==='A') state.moveLeft = true;
    if(e.key==='ArrowRight'|| e.key==='d' || e.key==='D') state.moveRight = true;
    if(e.key===' ' && !state.running) start(); // space to quick start
  });
  addEventListener('keyup', e=>{
    if(e.key==='ArrowLeft' || e.key==='a' || e.key==='A') state.moveLeft = false;
    if(e.key==='ArrowRight'|| e.key==='d' || e.key==='D') state.moveRight = false;
  });

  // Input (touch pads)
  function bindPad(el, dir){
    const on = ()=>{ state[dir] = true; };
    const off= ()=>{ state[dir] = false; };
    el.addEventListener('pointerdown', on, {passive:true});
    el.addEventListener('pointerup', off, {passive:true});
    el.addEventListener('pointerleave', off, {passive:true});
    el.addEventListener('touchstart', on, {passive:true});
    el.addEventListener('touchend', off, {passive:true});
  }
  bindPad(padL, 'moveLeft');
  bindPad(padR, 'moveRight');

  // Start/Restart
  startBtn.onclick = start;
  playBtn.onclick  = start;

  function start(){
    const W = cv.width/(window.devicePixelRatio||1);
    const H = cv.height/(window.devicePixelRatio||1);
    state.running = true; state.over=false;
    state.px = W/2; state.py = H - 60; state.vx = 0;
    state.speed = 3; state.score = 0; state.items.length = 0; state.t=0;
    overlay.style.display='none';
  }

  function gameOver(){
    state.running=false; state.over=true;
    if(state.score > best){ best = state.score; localStorage.setItem('sd_best', best); bestEl.textContent = best; }
    overlay.style.display='flex';
    overlay.querySelector('h1').textContent = 'Game Over';
    overlay.querySelector('.muted').innerHTML = `Score: <b>${state.score}</b> • Best: <b>${best}</b>`;
  }

  // ===== Entities =====
  // item: {x,y,w,h,type:'hazard'|'star'}
  function spawnRow(){
    const W = cv.width/(window.devicePixelRatio||1);
    // 3 lanes
    const lanes = [W*0.2, W*0.5, W*0.8];
    // always at least one thing
    const count = 2; // fixed for balance
    for(let i=0;i<count;i++){
      const lane = lanes.splice(Math.floor(Math.random()*lanes.length),1)[0];
      const type = Math.random()<0.33 ? 'star' : 'hazard';
      if(type==='hazard'){
        state.items.push({x: lane-28, y:-30, w:56, h:22, type});
      }else{
        state.items.push({x: lane-14, y:-30, w:28, h:28, type});
      }
    }
  }

  // ===== Update & Render =====
  function update(){
    const W = cv.width/(window.devicePixelRatio||1);
    const H = cv.height/(window.devicePixelRatio||1);
    if(!state.running){ render(); return; }
    state.t++;

    // Move player
    const accel = 0.9;
    if(state.moveLeft)  state.vx -= accel;
    if(state.moveRight) state.vx += accel;
    // friction & clamp
    state.vx *= 0.90;
    state.vx = Math.max(-6, Math.min(6, state.vx));
    state.px += state.vx;
    state.px = Math.max(24, Math.min(W-24, state.px));

    // Spawn rows
    if(state.t % 42 === 0) spawnRow();

    // Move items (downwards)
    for(const it of state.items){
      it.y += state.speed*1.6;
    }

    // Collisions & cleanup
    for(let i=state.items.length-1;i>=0;i--){
      const it = state.items[i];
      if(it.y > H+40){ state.items.splice(i,1); continue; }

      // AABB collision
      const px=state.px - state.pw/2, py=state.py - state.ph/2, pw=state.pw, ph=state.ph;
      if(it.type==='hazard'){
        if(rectsOverlap(px,py,pw,ph, it.x,it.y,it.w,it.h)) { gameOver(); return; }
      }else{ // star
        if(rectsOverlap(px,py,pw,ph, it.x,it.y,it.w,it.h)){
          state.score += 10;
          scoreEl.textContent = state.score;
          state.items.splice(i,1);
        }
      }
    }

    // Difficulty scale
    if(state.t % 300 === 0) state.speed = Math.min(6.5, state.speed + 0.4);

    render();
  }

  function rectsOverlap(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function render(){
    const W = cv.width/(window.devicePixelRatio||1);
    const H = cv.height/(window.devicePixelRatio||1);

    // background
    ctx.fillStyle='#0b0f24'; ctx.fillRect(0,0,W,H);

    // lane glow lines
    ctx.strokeStyle='rgba(108,207,255,.22)'; ctx.lineWidth=2;
    [W*0.2, W*0.5, W*0.8].forEach(x=>{ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); });

    // items
    for(const it of state.items){
      if(it.type==='hazard'){
        // red bar
        ctx.fillStyle='rgba(255,107,107,.9)';
        roundRect(it.x,it.y,it.w,it.h,6); ctx.fill();
        ctx.strokeStyle='rgba(255,255,255,.15)'; ctx.stroke();
      }else{ // star
        ctx.font = '22px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText('⭐', it.x+it.w/2, it.y+it.h/2);
      }
    }

    // player
    const px = state.px - state.pw/2, py = state.py - state.ph/2;
    // shadow
    ctx.fillStyle='rgba(124,255,196,.10)';
    ctx.beginPath(); ctx.ellipse(state.px, state.py+16, 28, 8, 0, 0, Math.PI*2); ctx.fill();
    // body
    ctx.fillStyle='#6cf';
    roundRect(px,py,state.pw,state.ph,8); ctx.fill();
    ctx.strokeStyle='rgba(108,207,255,.6)'; ctx.stroke();

    // subtle top glow line
    ctx.strokeStyle='rgba(124,255,196,.12)'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(10, 12); ctx.lineTo(W-10, 12); ctx.stroke();
  }

  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  // Loop
  let raf; function loop(){ update(); raf=requestAnimationFrame(loop); }
  raf=requestAnimationFrame(loop);
})();
</script>
</body>
</html>
